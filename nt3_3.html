<p class="has-line-data" data-line-start="1" data-line-end="2">Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c ‘cd /tmp’. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd.</p>
<p class="has-line-data" data-line-start="3" data-line-end="5">stat(&quot;/tmp&quot;, {st_mode=S_IFDIR|S_ISVTX|0777, st_size=4096, …}) = 0<br>
chdir(&quot;/tmp&quot;)</p>
<p class="has-line-data" data-line-start="7" data-line-end="15">Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:<br>
vagrant@netology1:~$ file /dev/tty<br>
/dev/tty: character special (5/0)<br>
vagrant@netology1:~$ file /dev/sda<br>
/dev/sda: block special (8/0)<br>
vagrant@netology1:~$ file /bin/bash<br>
/bin/bash: ELF 64-bit LSB shared object, x86-64<br>
Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.</p>
<p class="has-line-data" data-line-start="16" data-line-end="17">openat(AT_FDCWD, “/usr/share/misc/magic.mgc”, O_RDONLY) = 3</p>
<p class="has-line-data" data-line-start="20" data-line-end="21">Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).</p>
<p class="has-line-data" data-line-start="22" data-line-end="36">Есть несколько вариантов<br>
mike@HOMEDX79SR:~$ touch aaa.log<br>
Теперь обнуляем<br>
mike@HOMEDX79SR:~$ &gt; aaa.log<br>
mike@HOMEDX79SR:~$ true aaa.log<br>
mike@HOMEDX79SR:~$ :&gt; aaa.log<br>
mike@HOMEDX79SR:~$ cat /dev/null &gt; aaa.log<br>
mike@HOMEDX79SR:~$ cp /dev/null  aaa.log<br>
mike@HOMEDX79SR:~$ dd if=/dev/null of=aaa.log<br>
0+0 records in<br>
0+0 records out<br>
0 bytes copied, 0.0010079 s, 0.0 kB/s<br>
mike@HOMEDX79SR:~$ echo &gt; access.log<br>
mike@HOMEDX79SR:~$ truncate -s 0 aaa.log</p>
<p class="has-line-data" data-line-start="38" data-line-end="40">Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?<br>
Да занимают.</p>
<p class="has-line-data" data-line-start="42" data-line-end="58">В iovisor BCC есть утилита opensnoop:<br>
root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop<br>
/usr/sbin/opensnoop-bpfcc<br>
На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.<br>
agrant@vagrant:~$ sudo opensnoop-bpfcc<br>
PID    COMM               FD ERR PATH<br>
825    vminfo              6   0 /var/run/utmp<br>
551    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services<br>
551    dbus-daemon        18   0 /usr/share/dbus-1/system-services<br>
551    dbus-daemon        -1   2 /lib/dbus-1/system-services<br>
551    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/<br>
825    vminfo              6   0 /var/run/utmp<br>
551    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services<br>
551    dbus-daemon        18   0 /usr/share/dbus-1/system-services<br>
551    dbus-daemon        -1   2 /lib/dbus-1/system-services<br>
551    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/</p>
<p class="has-line-data" data-line-start="61" data-line-end="66">Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.<br>
<a href="https://man7.org/linux/man-pages/man2/uname.2.html">https://man7.org/linux/man-pages/man2/uname.2.html</a><br>
Part of the utsname information is also accessible via<br>
/proc/sys/kernel/{ostype, hostname, osrelease, version,<br>
domainname}.</p>
<p class="has-line-data" data-line-start="68" data-line-end="73">Чем отличается последовательность команд через ; и через &amp;&amp; в bash? Например:<br>
root@netology1:~# test -d /tmp/some_dir; echo Hi<br>
Hi<br>
root@netology1:~# test -d /tmp/some_dir &amp;&amp; echo Hi<br>
r          +    is in the foreground process group
</code></pre>
<p class="has-line-data" data-line-start="128" data-line-end="221">vagrant@vagrant:~$ ps -aux<br>
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>
root           1  0.0  1.1 167520 11404 ?        Ss   09:35   0:03 /sbin/init<br>
root           2  0.0  0.0      0     0 ?        S    09:35   0:00 [kthreadd]<br>
root           3  0.0  0.0      0     0 ?        I&lt;   09:35   0:00 [rcu_gp]<br>
root           4  0.0  0.0      0     0 ?        I&lt;   09:35   0:00 [rcu_par_gp]<br>
root           5  0.1  0.0      0     0 ?        I    09:35   0:10 [kworker/0:0-mm_percpu_wq]<br>
root           6  0.0  0.0      0     0 ?        I&lt;   09:35   0:00 [kworker/0:0H]<br>
root           8  0.0  0.0      0     0 ?        I&lt;   09:35   0:00 [mm_percpu_wq]<br>
root           9  0.0  0.0      0     0 ?        S    09:35   0:01 [ksoftirqd/0]<br>
root          10  0.0  0.0      0     0 ?        I    09:35   0:00 [rcu_sched]<br>
root          11  0.0  0.0      0     0 ?        S    09:35   0:00 [migration/0]<br>
root          12  0.0  0.0      0     0 ?        S    09:35   0:00 [idle_inject/0]<br>
root          14  0.0  0.0      0     0 ?        S    09:35   0:00 [cpuhp/0]<br>
root          15  0.0  0.0      0     0 ?        S    09:35   0:00 [kdevtmpfs]<br>
root          16  0.0  0.0      0     0 ?        I&lt;   09:35   0:00 [netns]<br>
root          17  0.0  0.0      0     0 ?        S    09:35   0:00 [rcu_tasks_kthre]<br>
root          18  0.0  0.0      0     0 ?        S    09:35   0:00 [kaud
